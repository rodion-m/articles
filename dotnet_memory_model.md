# Модель памяти .NET
В двух словах, модель памяти (memory model) — это довольно сложная, низкоуровневая и запутанная тема, которая, прежде всего, касается магии, которая может происходит в многопоточных приложениях. 
И в случае когда разработчики хотят достичь максимальной производительности (в обход относительного тяжелого `lock`), им приходится использовать `volatile` и порчие `барьеры памяти`.

# Что самое важное нужно знать про модель памяти?
То, что ключевое слово `volatile` лучше не использовать вообще, если вы хоть чуть-чуть не уверены в том, как это работает. Вот, кстати, черновик статьи про volatile (на английском): 

Если вам вдруг понадобился барьер памяти, то можно поставить полный барьер через `Thread.MemoryBarrier`, либо через методы из `Interlocked`.

В условных 99% случаев для синхронизации будет достаточно `lock` либо `SemaphoreSlim.WaitAsync`.

Где почитать про модель памятия в .NET?

Доступно несколько документов по этой теме.

Самый актуальный — это официальная спецификация: https://github.com/dotnet/runtime/blob/main/docs/design/specs/Memory-model.md

Еще документы:
* [ECMA 335: chapter "I.12.6 Memory Model and Optimizations"](https://github.com/rodion-m/articles/blob/main/documents/ecma_335_memory_model_and_optimizations.md)
* 
* [Memory model в mono](https://www.mono-project.com/docs/advanced/runtime/docs/atomics-memory-model/)
* И небольшое чтиво на русском из репозитория dotEducation
